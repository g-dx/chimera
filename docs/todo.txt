TODO:
=========

+ Picker Refactor
=================
Picker does the work of calculating block offsets and then discards them only to recalculate them again
for the peer.blocks map. Picker should be refactored to return offsets and we can add a method to
piecemap to return the length for a given offset.

+ Pure
======

Message handling probably can't be side-effect free without lots of work. Maybe?

+ PeerState
===========

type PeerState struct {
    wire WireState
    pending set[Block]
    downloaded counter
    uploaded counter
}

type BlockOffset uint64
func toOffset(index, begin int) BlockOffset {
    return uint64(index) * pieceSize + uint64(begin)
    // do bitshifting?
}


+ Simplify PeerIdentity
=======================
Currently this is a pointer to a struct. Really we want an opaque value. We can change this to be:

type PeerIdentity string

Which is immutable and can be passed around by value as a string is a glorified slice.
TODO: We need to check if this does indeed result only copying a pointer? -
DONE: Checked on go playground. Regardless of string size passing to a function always results in
an 8 byte copy being passed. This feels correct as strings are really:

type string struct {
    b []byte
    len int
}

With no way to alter the underlying slice.

+ Update peer storage to use map
================================
The protocol class should use a map to quickly find a peer for a given id.

+ Define new read-only Peer interface
=====================================
This should be used as inputs to already side-effect free functions. First pass is this:

type Peer interface {
	Id() PeerIdentity
	State() WireState
	Has(index int) bool
	Pending() int
	Download() int
	Upload() int
}

Not sure if this will work well enough with OnMessages(...) handler function.

+ Deduplicate outgoing writes
=============================
The code to perform writes is duplicated.

+ Add Incoming&Outgoing Adaptive Buffer Sizing
==============================================
Straightforward for outgoing. If we flush before the flush timer fires X times in a row then double
buffer size. Similarly if the flush timer causes network writes X times in a row and the buffer is
less than half full halve the buffer size.

Incoming not too sure....

+ Picker Improvement
====================
The picker should consider how many blocks in a piece when calculating the "available pieces". This
will minimise the amount of loops.